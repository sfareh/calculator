{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nvar name = 'matrixFromFunction';\nvar dependencies = ['typed', 'matrix', 'isZero'];\nexport var createMatrixFromFunction = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    isZero\n  } = _ref;\n  /**\n   * Create a matrix by evaluating a generating function at each index.\n   * The simplest overload returns a multi-dimensional array as long as `size` is an array.\n   * Passing `size` as a Matrix or specifying a `format` will result in returning a Matrix.\n   *\n   * Syntax:\n   *\n   *    math.matrixFromFunction(size, fn)\n   *    math.matrixFromFunction(size, fn, format)\n   *    math.matrixFromFunction(size, fn, format, datatype)\n   *    math.matrixFromFunction(size, format, fn)\n   *    math.matrixFromFunction(size, format, datatype, fn)\n   *\n   * Examples:\n   *\n   *    math.matrixFromFunction([3,3], i => i[0] - i[1]) // an antisymmetric matrix\n   *    math.matrixFromFunction([100, 100], 'sparse', i => i[0] - i[1] === 1 ? 4 : 0) // a sparse subdiagonal matrix\n   *    math.matrixFromFunction([5], i => math.random()) // a random vector\n   *\n   * See also:\n   *\n   *    matrix, zeros\n   *\n   * @param {Array | Matrix} size   The size of the matrix to be created\n   * @param {function} fn           Callback function invoked for every entry in the matrix\n   * @param {string} [format]       The Matrix storage format, either `'dense'` or `'sparse'`\n   * @param {string} [datatype]     Type of the values\n   * @return {Array | Matrix} Returns the created matrix\n   */\n\n  return typed(name, {\n    'Array | Matrix, function, string, string': function ArrayMatrixFunctionStringString(size, fn, format, datatype) {\n      return _create(size, fn, format, datatype);\n    },\n    'Array | Matrix, function, string': function ArrayMatrixFunctionString(size, fn, format) {\n      return _create(size, fn, format);\n    },\n    'Matrix, function': function MatrixFunction(size, fn) {\n      return _create(size, fn, 'dense');\n    },\n    'Array, function': function ArrayFunction(size, fn) {\n      return _create(size, fn, 'dense').toArray();\n    },\n    'Array | Matrix, string, function': function ArrayMatrixStringFunction(size, format, fn) {\n      return _create(size, fn, format);\n    },\n    'Array | Matrix, string, string, function': function ArrayMatrixStringStringFunction(size, format, datatype, fn) {\n      return _create(size, fn, format, datatype);\n    }\n  });\n\n  function _create(size, fn, format, datatype) {\n    var m;\n\n    if (datatype !== undefined) {\n      m = matrix(format, datatype);\n    } else {\n      m = matrix(format);\n    }\n\n    m.resize(size);\n    m.forEach(function (_, index) {\n      var val = fn(index);\n      if (isZero(val)) return;\n      m.set(index, val);\n    });\n    return m;\n  }\n});","map":{"version":3,"sources":["/Users/sarahrouini/PMN/calculator/node_modules/mathjs/lib/esm/function/matrix/matrixFromFunction.js"],"names":["factory","name","dependencies","createMatrixFromFunction","_ref","typed","matrix","isZero","ArrayMatrixFunctionStringString","size","fn","format","datatype","_create","ArrayMatrixFunctionString","MatrixFunction","ArrayFunction","toArray","ArrayMatrixStringFunction","ArrayMatrixStringStringFunction","m","undefined","resize","forEach","_","index","val","set"],"mappings":"AAAA,SAASA,OAAT,QAAwB,wBAAxB;AACA,IAAIC,IAAI,GAAG,oBAAX;AACA,IAAIC,YAAY,GAAG,CAAC,OAAD,EAAU,QAAV,EAAoB,QAApB,CAAnB;AACA,OAAO,IAAIC,wBAAwB,GAAG,eAAeH,OAAO,CAACC,IAAD,EAAOC,YAAP,EAAqBE,IAAI,IAAI;AACvF,MAAI;AACFC,IAAAA,KADE;AAEFC,IAAAA,MAFE;AAGFC,IAAAA;AAHE,MAIAH,IAJJ;AAMA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAOC,KAAK,CAACJ,IAAD,EAAO;AACjB,gDAA4C,SAASO,+BAAT,CAAyCC,IAAzC,EAA+CC,EAA/C,EAAmDC,MAAnD,EAA2DC,QAA3D,EAAqE;AAC/G,aAAOC,OAAO,CAACJ,IAAD,EAAOC,EAAP,EAAWC,MAAX,EAAmBC,QAAnB,CAAd;AACD,KAHgB;AAIjB,wCAAoC,SAASE,yBAAT,CAAmCL,IAAnC,EAAyCC,EAAzC,EAA6CC,MAA7C,EAAqD;AACvF,aAAOE,OAAO,CAACJ,IAAD,EAAOC,EAAP,EAAWC,MAAX,CAAd;AACD,KANgB;AAOjB,wBAAoB,SAASI,cAAT,CAAwBN,IAAxB,EAA8BC,EAA9B,EAAkC;AACpD,aAAOG,OAAO,CAACJ,IAAD,EAAOC,EAAP,EAAW,OAAX,CAAd;AACD,KATgB;AAUjB,uBAAmB,SAASM,aAAT,CAAuBP,IAAvB,EAA6BC,EAA7B,EAAiC;AAClD,aAAOG,OAAO,CAACJ,IAAD,EAAOC,EAAP,EAAW,OAAX,CAAP,CAA2BO,OAA3B,EAAP;AACD,KAZgB;AAajB,wCAAoC,SAASC,yBAAT,CAAmCT,IAAnC,EAAyCE,MAAzC,EAAiDD,EAAjD,EAAqD;AACvF,aAAOG,OAAO,CAACJ,IAAD,EAAOC,EAAP,EAAWC,MAAX,CAAd;AACD,KAfgB;AAgBjB,gDAA4C,SAASQ,+BAAT,CAAyCV,IAAzC,EAA+CE,MAA/C,EAAuDC,QAAvD,EAAiEF,EAAjE,EAAqE;AAC/G,aAAOG,OAAO,CAACJ,IAAD,EAAOC,EAAP,EAAWC,MAAX,EAAmBC,QAAnB,CAAd;AACD;AAlBgB,GAAP,CAAZ;;AAqBA,WAASC,OAAT,CAAiBJ,IAAjB,EAAuBC,EAAvB,EAA2BC,MAA3B,EAAmCC,QAAnC,EAA6C;AAC3C,QAAIQ,CAAJ;;AAEA,QAAIR,QAAQ,KAAKS,SAAjB,EAA4B;AAC1BD,MAAAA,CAAC,GAAGd,MAAM,CAACK,MAAD,EAASC,QAAT,CAAV;AACD,KAFD,MAEO;AACLQ,MAAAA,CAAC,GAAGd,MAAM,CAACK,MAAD,CAAV;AACD;;AAEDS,IAAAA,CAAC,CAACE,MAAF,CAASb,IAAT;AACAW,IAAAA,CAAC,CAACG,OAAF,CAAU,UAAUC,CAAV,EAAaC,KAAb,EAAoB;AAC5B,UAAIC,GAAG,GAAGhB,EAAE,CAACe,KAAD,CAAZ;AACA,UAAIlB,MAAM,CAACmB,GAAD,CAAV,EAAiB;AACjBN,MAAAA,CAAC,CAACO,GAAF,CAAMF,KAAN,EAAaC,GAAb;AACD,KAJD;AAKA,WAAON,CAAP;AACD;AACF,CA1E2D,CAArD","sourcesContent":["import { factory } from '../../utils/factory.js';\nvar name = 'matrixFromFunction';\nvar dependencies = ['typed', 'matrix', 'isZero'];\nexport var createMatrixFromFunction = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    isZero\n  } = _ref;\n\n  /**\n   * Create a matrix by evaluating a generating function at each index.\n   * The simplest overload returns a multi-dimensional array as long as `size` is an array.\n   * Passing `size` as a Matrix or specifying a `format` will result in returning a Matrix.\n   *\n   * Syntax:\n   *\n   *    math.matrixFromFunction(size, fn)\n   *    math.matrixFromFunction(size, fn, format)\n   *    math.matrixFromFunction(size, fn, format, datatype)\n   *    math.matrixFromFunction(size, format, fn)\n   *    math.matrixFromFunction(size, format, datatype, fn)\n   *\n   * Examples:\n   *\n   *    math.matrixFromFunction([3,3], i => i[0] - i[1]) // an antisymmetric matrix\n   *    math.matrixFromFunction([100, 100], 'sparse', i => i[0] - i[1] === 1 ? 4 : 0) // a sparse subdiagonal matrix\n   *    math.matrixFromFunction([5], i => math.random()) // a random vector\n   *\n   * See also:\n   *\n   *    matrix, zeros\n   *\n   * @param {Array | Matrix} size   The size of the matrix to be created\n   * @param {function} fn           Callback function invoked for every entry in the matrix\n   * @param {string} [format]       The Matrix storage format, either `'dense'` or `'sparse'`\n   * @param {string} [datatype]     Type of the values\n   * @return {Array | Matrix} Returns the created matrix\n   */\n  return typed(name, {\n    'Array | Matrix, function, string, string': function ArrayMatrixFunctionStringString(size, fn, format, datatype) {\n      return _create(size, fn, format, datatype);\n    },\n    'Array | Matrix, function, string': function ArrayMatrixFunctionString(size, fn, format) {\n      return _create(size, fn, format);\n    },\n    'Matrix, function': function MatrixFunction(size, fn) {\n      return _create(size, fn, 'dense');\n    },\n    'Array, function': function ArrayFunction(size, fn) {\n      return _create(size, fn, 'dense').toArray();\n    },\n    'Array | Matrix, string, function': function ArrayMatrixStringFunction(size, format, fn) {\n      return _create(size, fn, format);\n    },\n    'Array | Matrix, string, string, function': function ArrayMatrixStringStringFunction(size, format, datatype, fn) {\n      return _create(size, fn, format, datatype);\n    }\n  });\n\n  function _create(size, fn, format, datatype) {\n    var m;\n\n    if (datatype !== undefined) {\n      m = matrix(format, datatype);\n    } else {\n      m = matrix(format);\n    }\n\n    m.resize(size);\n    m.forEach(function (_, index) {\n      var val = fn(index);\n      if (isZero(val)) return;\n      m.set(index, val);\n    });\n    return m;\n  }\n});"]},"metadata":{},"sourceType":"module"}