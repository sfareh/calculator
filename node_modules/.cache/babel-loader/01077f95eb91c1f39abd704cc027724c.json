{"ast":null,"code":"import { isAccessorNode, isArrayNode, isConstantNode, isFunctionNode, isIndexNode, isObjectNode, isOperatorNode, isParenthesisNode, isSymbolNode } from '../../../utils/is.js';\nimport { factory } from '../../../utils/factory.js';\nvar name = 'simplifyCore';\nvar dependencies = ['equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode'];\nexport var createSimplifyCore = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    equal,\n    isZero,\n    add,\n    subtract,\n    multiply,\n    divide,\n    pow,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    ParenthesisNode\n  } = _ref;\n  var node0 = new ConstantNode(0);\n  var node1 = new ConstantNode(1);\n\n  function mapSimplifyCore(nodeArray) {\n    return nodeArray.map(simplifyCore).map(function (arg) {\n      return isParenthesisNode(arg) ? arg.content : arg;\n    });\n  }\n  /**\n   * simplifyCore() performs single pass simplification suitable for\n   * applications requiring ultimate performance. In contrast, simplify()\n   * extends simplifyCore() with additional passes to provide deeper\n   * simplification.\n   *\n   * Syntax:\n   *\n   *     simplify.simplifyCore(expr)\n   *\n   * Examples:\n   *\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simplify.simpifyCore(f)                          // Node {2 * x}\n   *     math.simplify('2 * 1 * x ^ (2 - 1)', [math.simplify.simpifyCore]) // Node {2 * x}\n   *\n   * See also:\n   *\n   *     derivative\n   *\n   * @param {Node} node\n   *     The expression to be simplified\n   */\n\n\n  function simplifyCore(node) {\n    if (isOperatorNode(node) && node.isUnary()) {\n      var a0 = simplifyCore(node.args[0]);\n\n      if (node.op === '+') {\n        // unary plus\n        return a0;\n      }\n\n      if (node.op === '-') {\n        // unary minus\n        if (isOperatorNode(a0)) {\n          if (a0.isUnary() && a0.op === '-') {\n            return a0.args[0];\n          } else if (a0.isBinary() && a0.fn === 'subtract') {\n            return new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [a0]);\n      }\n    } else if (isOperatorNode(node) && node.isBinary()) {\n      var _a = simplifyCore(node.args[0]);\n\n      var a1 = simplifyCore(node.args[1]);\n\n      if (node.op === '+') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(add(_a.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1) && isZero(a1.value)) {\n          return _a;\n        }\n\n        if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n          return new OperatorNode('-', 'subtract', [_a, a1.args[0]]);\n        }\n\n        return new OperatorNode(node.op, node.fn, a1 ? [_a, a1] : [_a]);\n      } else if (node.op === '-') {\n        if (isConstantNode(_a) && a1) {\n          if (isConstantNode(a1)) {\n            return new ConstantNode(subtract(_a.value, a1.value));\n          } else if (isZero(_a.value)) {\n            return new OperatorNode('-', 'unaryMinus', [a1]);\n          }\n        } // if (node.fn === \"subtract\" && node.args.length === 2) {\n\n\n        if (node.fn === 'subtract') {\n          if (isConstantNode(a1) && isZero(a1.value)) {\n            return _a;\n          }\n\n          if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n            return simplifyCore(new OperatorNode('+', 'add', [_a, a1.args[0]]));\n          }\n\n          return new OperatorNode(node.op, node.fn, [_a, a1]);\n        }\n      } else if (node.op === '*') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (equal(_a.value, 1)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(multiply(_a.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node0;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === node.op) {\n            var a00 = _a.args[0];\n\n            if (isConstantNode(a00)) {\n              var a00a1 = new ConstantNode(multiply(a00.value, a1.value));\n              return new OperatorNode(node.op, node.fn, [a00a1, _a.args[1]], node.implicit); // constants on left\n            }\n          }\n\n          return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit); // constants on left\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n      } else if (node.op === '/') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (isConstantNode(a1) && (equal(a1.value, 1) || equal(a1.value, 2) || equal(a1.value, 4))) {\n            return new ConstantNode(divide(_a.value, a1.value));\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      } else if (node.op === '^') {\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node1;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else {\n            if (isConstantNode(_a)) {\n              // fold constant\n              return new ConstantNode(pow(_a.value, a1.value));\n            } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === '^') {\n              var a01 = _a.args[1];\n\n              if (isConstantNode(a01)) {\n                return new OperatorNode(node.op, node.fn, [_a.args[0], new ConstantNode(multiply(a01.value, a1.value))]);\n              }\n            }\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      }\n    } else if (isParenthesisNode(node)) {\n      var c = simplifyCore(node.content);\n\n      if (isParenthesisNode(c) || isSymbolNode(c) || isConstantNode(c)) {\n        return c;\n      }\n\n      return new ParenthesisNode(c);\n    } else if (isFunctionNode(node)) {\n      return new FunctionNode(simplifyCore(node.fn), mapSimplifyCore(node.args));\n    } else if (isArrayNode(node)) {\n      return new ArrayNode(mapSimplifyCore(node.items));\n    } else if (isAccessorNode(node)) {\n      var obj = mapSimplifyCore(node.object);\n\n      if (isParenthesisNode(obj)) {\n        obj = obj.content;\n      }\n\n      return new AccessorNode(obj, simplifyCore(node.index));\n    } else if (isIndexNode(node)) {\n      return new IndexNode(mapSimplifyCore(node.dimensions));\n    } else if (isObjectNode(node)) {\n      var newProps = {};\n\n      for (var prop in node.properties) {\n        newProps[prop] = simplifyCore(node.properties[prop]);\n      }\n\n      return new ObjectNode(newProps);\n    } else {// cannot simplify\n    }\n\n    return node;\n  }\n\n  return simplifyCore;\n});","map":{"version":3,"sources":["/Users/sarahrouini/PMN/calculator/node_modules/mathjs/lib/esm/function/algebra/simplify/simplifyCore.js"],"names":["isAccessorNode","isArrayNode","isConstantNode","isFunctionNode","isIndexNode","isObjectNode","isOperatorNode","isParenthesisNode","isSymbolNode","factory","name","dependencies","createSimplifyCore","_ref","equal","isZero","add","subtract","multiply","divide","pow","AccessorNode","ArrayNode","ConstantNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","ParenthesisNode","node0","node1","mapSimplifyCore","nodeArray","map","simplifyCore","arg","content","node","isUnary","a0","args","op","isBinary","fn","_a","a1","value","a00","a00a1","implicit","a01","c","items","obj","object","index","dimensions","newProps","prop","properties"],"mappings":"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","sourcesContent":["import { isAccessorNode, isArrayNode, isConstantNode, isFunctionNode, isIndexNode, isObjectNode, isOperatorNode, isParenthesisNode, isSymbolNode } from '../../../utils/is.js';\nimport { factory } from '../../../utils/factory.js';\nvar name = 'simplifyCore';\nvar dependencies = ['equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode'];\nexport var createSimplifyCore = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    equal,\n    isZero,\n    add,\n    subtract,\n    multiply,\n    divide,\n    pow,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    ParenthesisNode\n  } = _ref;\n  var node0 = new ConstantNode(0);\n  var node1 = new ConstantNode(1);\n\n  function mapSimplifyCore(nodeArray) {\n    return nodeArray.map(simplifyCore).map(function (arg) {\n      return isParenthesisNode(arg) ? arg.content : arg;\n    });\n  }\n  /**\n   * simplifyCore() performs single pass simplification suitable for\n   * applications requiring ultimate performance. In contrast, simplify()\n   * extends simplifyCore() with additional passes to provide deeper\n   * simplification.\n   *\n   * Syntax:\n   *\n   *     simplify.simplifyCore(expr)\n   *\n   * Examples:\n   *\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simplify.simpifyCore(f)                          // Node {2 * x}\n   *     math.simplify('2 * 1 * x ^ (2 - 1)', [math.simplify.simpifyCore]) // Node {2 * x}\n   *\n   * See also:\n   *\n   *     derivative\n   *\n   * @param {Node} node\n   *     The expression to be simplified\n   */\n\n\n  function simplifyCore(node) {\n    if (isOperatorNode(node) && node.isUnary()) {\n      var a0 = simplifyCore(node.args[0]);\n\n      if (node.op === '+') {\n        // unary plus\n        return a0;\n      }\n\n      if (node.op === '-') {\n        // unary minus\n        if (isOperatorNode(a0)) {\n          if (a0.isUnary() && a0.op === '-') {\n            return a0.args[0];\n          } else if (a0.isBinary() && a0.fn === 'subtract') {\n            return new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [a0]);\n      }\n    } else if (isOperatorNode(node) && node.isBinary()) {\n      var _a = simplifyCore(node.args[0]);\n\n      var a1 = simplifyCore(node.args[1]);\n\n      if (node.op === '+') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(add(_a.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1) && isZero(a1.value)) {\n          return _a;\n        }\n\n        if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n          return new OperatorNode('-', 'subtract', [_a, a1.args[0]]);\n        }\n\n        return new OperatorNode(node.op, node.fn, a1 ? [_a, a1] : [_a]);\n      } else if (node.op === '-') {\n        if (isConstantNode(_a) && a1) {\n          if (isConstantNode(a1)) {\n            return new ConstantNode(subtract(_a.value, a1.value));\n          } else if (isZero(_a.value)) {\n            return new OperatorNode('-', 'unaryMinus', [a1]);\n          }\n        } // if (node.fn === \"subtract\" && node.args.length === 2) {\n\n\n        if (node.fn === 'subtract') {\n          if (isConstantNode(a1) && isZero(a1.value)) {\n            return _a;\n          }\n\n          if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n            return simplifyCore(new OperatorNode('+', 'add', [_a, a1.args[0]]));\n          }\n\n          return new OperatorNode(node.op, node.fn, [_a, a1]);\n        }\n      } else if (node.op === '*') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (equal(_a.value, 1)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(multiply(_a.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node0;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === node.op) {\n            var a00 = _a.args[0];\n\n            if (isConstantNode(a00)) {\n              var a00a1 = new ConstantNode(multiply(a00.value, a1.value));\n              return new OperatorNode(node.op, node.fn, [a00a1, _a.args[1]], node.implicit); // constants on left\n            }\n          }\n\n          return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit); // constants on left\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n      } else if (node.op === '/') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (isConstantNode(a1) && (equal(a1.value, 1) || equal(a1.value, 2) || equal(a1.value, 4))) {\n            return new ConstantNode(divide(_a.value, a1.value));\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      } else if (node.op === '^') {\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node1;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else {\n            if (isConstantNode(_a)) {\n              // fold constant\n              return new ConstantNode(pow(_a.value, a1.value));\n            } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === '^') {\n              var a01 = _a.args[1];\n\n              if (isConstantNode(a01)) {\n                return new OperatorNode(node.op, node.fn, [_a.args[0], new ConstantNode(multiply(a01.value, a1.value))]);\n              }\n            }\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      }\n    } else if (isParenthesisNode(node)) {\n      var c = simplifyCore(node.content);\n\n      if (isParenthesisNode(c) || isSymbolNode(c) || isConstantNode(c)) {\n        return c;\n      }\n\n      return new ParenthesisNode(c);\n    } else if (isFunctionNode(node)) {\n      return new FunctionNode(simplifyCore(node.fn), mapSimplifyCore(node.args));\n    } else if (isArrayNode(node)) {\n      return new ArrayNode(mapSimplifyCore(node.items));\n    } else if (isAccessorNode(node)) {\n      var obj = mapSimplifyCore(node.object);\n\n      if (isParenthesisNode(obj)) {\n        obj = obj.content;\n      }\n\n      return new AccessorNode(obj, simplifyCore(node.index));\n    } else if (isIndexNode(node)) {\n      return new IndexNode(mapSimplifyCore(node.dimensions));\n    } else if (isObjectNode(node)) {\n      var newProps = {};\n\n      for (var prop in node.properties) {\n        newProps[prop] = simplifyCore(node.properties[prop]);\n      }\n\n      return new ObjectNode(newProps);\n    } else {// cannot simplify\n    }\n\n    return node;\n  }\n\n  return simplifyCore;\n});"]},"metadata":{},"sourceType":"module"}