{"ast":null,"code":"import { isArrayNode, isNode } from '../../utils/is.js';\nimport { map } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'ArrayNode';\nvar dependencies = ['Node'];\nexport var createArrayNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  /**\n   * @constructor ArrayNode\n   * @extends {Node}\n   * Holds an 1-dimensional array with items\n   * @param {Node[]} [items]   1 dimensional array with items\n   */\n\n  function ArrayNode(items) {\n    if (!(this instanceof ArrayNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.items = items || []; // validate input\n\n    if (!Array.isArray(this.items) || !this.items.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected');\n    }\n  }\n\n  ArrayNode.prototype = new Node();\n  ArrayNode.prototype.type = 'ArrayNode';\n  ArrayNode.prototype.isArrayNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ArrayNode.prototype._compile = function (math, argNames) {\n    var evalItems = map(this.items, function (item) {\n      return item._compile(math, argNames);\n    });\n    var asMatrix = math.config.matrix !== 'Array';\n\n    if (asMatrix) {\n      var matrix = math.matrix;\n      return function evalArrayNode(scope, args, context) {\n        return matrix(map(evalItems, function (evalItem) {\n          return evalItem(scope, args, context);\n        }));\n      };\n    } else {\n      return function evalArrayNode(scope, args, context) {\n        return map(evalItems, function (evalItem) {\n          return evalItem(scope, args, context);\n        });\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  ArrayNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.items.length; i++) {\n      var node = this.items[i];\n      callback(node, 'items[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new ArrayNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ArrayNode} Returns a transformed copy of the node\n   */\n\n\n  ArrayNode.prototype.map = function (callback) {\n    var items = [];\n\n    for (var i = 0; i < this.items.length; i++) {\n      items[i] = this._ifNode(callback(this.items[i], 'items[' + i + ']', this));\n    }\n\n    return new ArrayNode(items);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ArrayNode}\n   */\n\n\n  ArrayNode.prototype.clone = function () {\n    return new ArrayNode(this.items.slice(0));\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ArrayNode.prototype._toString = function (options) {\n    var items = this.items.map(function (node) {\n      return node.toString(options);\n    });\n    return '[' + items.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  ArrayNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ArrayNode',\n      items: this.items\n    };\n  };\n  /**\n   * Instantiate an ArrayNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ArrayNode\", items: [...]}`,\n   *                       where mathjs is optional\n   * @returns {ArrayNode}\n   */\n\n\n  ArrayNode.fromJSON = function (json) {\n    return new ArrayNode(json.items);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ArrayNode.prototype.toHTML = function (options) {\n    var items = this.items.map(function (node) {\n      return node.toHTML(options);\n    });\n    return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + items.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ArrayNode.prototype._toTex = function (options) {\n    function itemsToTex(items, nested) {\n      var mixedItems = items.some(isArrayNode) && !items.every(isArrayNode);\n      var itemsFormRow = nested || mixedItems;\n      var itemSep = itemsFormRow ? '&' : '\\\\\\\\';\n      var itemsTex = items.map(function (node) {\n        if (node.items) {\n          return itemsToTex(node.items, !nested);\n        } else {\n          return node.toTex(options);\n        }\n      }).join(itemSep);\n      return mixedItems || !itemsFormRow || itemsFormRow && !nested ? '\\\\begin{bmatrix}' + itemsTex + '\\\\end{bmatrix}' : itemsTex;\n    }\n\n    return itemsToTex(this.items, false);\n  };\n\n  return ArrayNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["/Users/sarahrouini/PMN/calculator/node_modules/mathjs/lib/esm/expression/node/ArrayNode.js"],"names":["isArrayNode","isNode","map","factory","name","dependencies","createArrayNode","_ref","Node","ArrayNode","items","SyntaxError","Array","isArray","every","TypeError","prototype","type","_compile","math","argNames","evalItems","item","asMatrix","config","matrix","evalArrayNode","scope","args","context","evalItem","forEach","callback","i","length","node","_ifNode","clone","slice","_toString","options","toString","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","itemsToTex","nested","mixedItems","some","itemsFormRow","itemSep","itemsTex","toTex","isClass"],"mappings":"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","sourcesContent":["import { isArrayNode, isNode } from '../../utils/is.js';\nimport { map } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'ArrayNode';\nvar dependencies = ['Node'];\nexport var createArrayNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n\n  /**\n   * @constructor ArrayNode\n   * @extends {Node}\n   * Holds an 1-dimensional array with items\n   * @param {Node[]} [items]   1 dimensional array with items\n   */\n  function ArrayNode(items) {\n    if (!(this instanceof ArrayNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.items = items || []; // validate input\n\n    if (!Array.isArray(this.items) || !this.items.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected');\n    }\n  }\n\n  ArrayNode.prototype = new Node();\n  ArrayNode.prototype.type = 'ArrayNode';\n  ArrayNode.prototype.isArrayNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ArrayNode.prototype._compile = function (math, argNames) {\n    var evalItems = map(this.items, function (item) {\n      return item._compile(math, argNames);\n    });\n    var asMatrix = math.config.matrix !== 'Array';\n\n    if (asMatrix) {\n      var matrix = math.matrix;\n      return function evalArrayNode(scope, args, context) {\n        return matrix(map(evalItems, function (evalItem) {\n          return evalItem(scope, args, context);\n        }));\n      };\n    } else {\n      return function evalArrayNode(scope, args, context) {\n        return map(evalItems, function (evalItem) {\n          return evalItem(scope, args, context);\n        });\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  ArrayNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.items.length; i++) {\n      var node = this.items[i];\n      callback(node, 'items[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new ArrayNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ArrayNode} Returns a transformed copy of the node\n   */\n\n\n  ArrayNode.prototype.map = function (callback) {\n    var items = [];\n\n    for (var i = 0; i < this.items.length; i++) {\n      items[i] = this._ifNode(callback(this.items[i], 'items[' + i + ']', this));\n    }\n\n    return new ArrayNode(items);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ArrayNode}\n   */\n\n\n  ArrayNode.prototype.clone = function () {\n    return new ArrayNode(this.items.slice(0));\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ArrayNode.prototype._toString = function (options) {\n    var items = this.items.map(function (node) {\n      return node.toString(options);\n    });\n    return '[' + items.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  ArrayNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ArrayNode',\n      items: this.items\n    };\n  };\n  /**\n   * Instantiate an ArrayNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ArrayNode\", items: [...]}`,\n   *                       where mathjs is optional\n   * @returns {ArrayNode}\n   */\n\n\n  ArrayNode.fromJSON = function (json) {\n    return new ArrayNode(json.items);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ArrayNode.prototype.toHTML = function (options) {\n    var items = this.items.map(function (node) {\n      return node.toHTML(options);\n    });\n    return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + items.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ArrayNode.prototype._toTex = function (options) {\n    function itemsToTex(items, nested) {\n      var mixedItems = items.some(isArrayNode) && !items.every(isArrayNode);\n      var itemsFormRow = nested || mixedItems;\n      var itemSep = itemsFormRow ? '&' : '\\\\\\\\';\n      var itemsTex = items.map(function (node) {\n        if (node.items) {\n          return itemsToTex(node.items, !nested);\n        } else {\n          return node.toTex(options);\n        }\n      }).join(itemSep);\n      return mixedItems || !itemsFormRow || itemsFormRow && !nested ? '\\\\begin{bmatrix}' + itemsTex + '\\\\end{bmatrix}' : itemsTex;\n    }\n\n    return itemsToTex(this.items, false);\n  };\n\n  return ArrayNode;\n}, {\n  isClass: true,\n  isNode: true\n});"]},"metadata":{},"sourceType":"module"}