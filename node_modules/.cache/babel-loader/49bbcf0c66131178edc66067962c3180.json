{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nvar name = 'matrixFromRows';\nvar dependencies = ['typed', 'matrix', 'flatten', 'size'];\nexport var createMatrixFromRows = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    flatten,\n    size\n  } = _ref;\n  /**\n   * Create a dense matrix from vectors as individual rows.\n   * If you pass column vectors, they will be transposed (but not conjugated!)\n   *\n   * Syntax:\n   *\n   *    math.matrixFromRows(...arr)\n   *    math.matrixFromRows(row1, row2)\n   *    math.matrixFromRows(row1, row2, row3)\n   *\n   * Examples:\n   *\n   *    math.matrixFromRows([1, 2, 3], [[4],[5],[6]])\n   *    math.matrixFromRows(...vectors)\n   *\n   * See also:\n   *\n   *    matrix, matrixFromColumns, matrixFromFunction, zeros\n   *\n   * @param {... Array | Matrix} rows  Multiple rows\n   * @return { number[][] | Matrix } if at least one of the arguments is an array, an array will be returned\n   */\n\n  return typed(name, {\n    '...Array': function Array(arr) {\n      return _createArray(arr);\n    },\n    '...Matrix': function Matrix(arr) {\n      return matrix(_createArray(arr.map(m => m.toArray())));\n    } // TODO implement this properly for SparseMatrix\n\n  });\n\n  function _createArray(arr) {\n    if (arr.length === 0) throw new TypeError('At least one row is needed to construct a matrix.');\n    var N = checkVectorTypeAndReturnLength(arr[0]);\n    var result = [];\n\n    for (var row of arr) {\n      var rowLength = checkVectorTypeAndReturnLength(row);\n\n      if (rowLength !== N) {\n        throw new TypeError('The vectors had different length: ' + (N | 0) + ' ≠ ' + (rowLength | 0));\n      }\n\n      result.push(flatten(row));\n    }\n\n    return result;\n  }\n\n  function checkVectorTypeAndReturnLength(vec) {\n    var s = size(vec);\n\n    if (s.length === 1) {\n      // 1D vector\n      return s[0];\n    } else if (s.length === 2) {\n      // 2D vector\n      if (s[0] === 1) {\n        // row vector\n        return s[1];\n      } else if (s[1] === 1) {\n        // col vector\n        return s[0];\n      } else {\n        throw new TypeError('At least one of the arguments is not a vector.');\n      }\n    } else {\n      throw new TypeError('Only one- or two-dimensional vectors are supported.');\n    }\n  }\n});","map":{"version":3,"sources":["/Users/sarahrouini/PMN/calculator/node_modules/mathjs/lib/esm/function/matrix/matrixFromRows.js"],"names":["factory","name","dependencies","createMatrixFromRows","_ref","typed","matrix","flatten","size","Array","arr","_createArray","Matrix","map","m","toArray","length","TypeError","N","checkVectorTypeAndReturnLength","result","row","rowLength","push","vec","s"],"mappings":"AAAA,SAASA,OAAT,QAAwB,wBAAxB;AACA,IAAIC,IAAI,GAAG,gBAAX;AACA,IAAIC,YAAY,GAAG,CAAC,OAAD,EAAU,QAAV,EAAoB,SAApB,EAA+B,MAA/B,CAAnB;AACA,OAAO,IAAIC,oBAAoB,GAAG,eAAeH,OAAO,CAACC,IAAD,EAAOC,YAAP,EAAqBE,IAAI,IAAI;AACnF,MAAI;AACFC,IAAAA,KADE;AAEFC,IAAAA,MAFE;AAGFC,IAAAA,OAHE;AAIFC,IAAAA;AAJE,MAKAJ,IALJ;AAOA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAOC,KAAK,CAACJ,IAAD,EAAO;AACjB,gBAAY,SAASQ,KAAT,CAAeC,GAAf,EAAoB;AAC9B,aAAOC,YAAY,CAACD,GAAD,CAAnB;AACD,KAHgB;AAIjB,iBAAa,SAASE,MAAT,CAAgBF,GAAhB,EAAqB;AAChC,aAAOJ,MAAM,CAACK,YAAY,CAACD,GAAG,CAACG,GAAJ,CAAQC,CAAC,IAAIA,CAAC,CAACC,OAAF,EAAb,CAAD,CAAb,CAAb;AACD,KANgB,CAMf;;AANe,GAAP,CAAZ;;AAUA,WAASJ,YAAT,CAAsBD,GAAtB,EAA2B;AACzB,QAAIA,GAAG,CAACM,MAAJ,KAAe,CAAnB,EAAsB,MAAM,IAAIC,SAAJ,CAAc,mDAAd,CAAN;AACtB,QAAIC,CAAC,GAAGC,8BAA8B,CAACT,GAAG,CAAC,CAAD,CAAJ,CAAtC;AACA,QAAIU,MAAM,GAAG,EAAb;;AAEA,SAAK,IAAIC,GAAT,IAAgBX,GAAhB,EAAqB;AACnB,UAAIY,SAAS,GAAGH,8BAA8B,CAACE,GAAD,CAA9C;;AAEA,UAAIC,SAAS,KAAKJ,CAAlB,EAAqB;AACnB,cAAM,IAAID,SAAJ,CAAc,wCAAwCC,CAAC,GAAG,CAA5C,IAAiD,KAAjD,IAA0DI,SAAS,GAAG,CAAtE,CAAd,CAAN;AACD;;AAEDF,MAAAA,MAAM,CAACG,IAAP,CAAYhB,OAAO,CAACc,GAAD,CAAnB;AACD;;AAED,WAAOD,MAAP;AACD;;AAED,WAASD,8BAAT,CAAwCK,GAAxC,EAA6C;AAC3C,QAAIC,CAAC,GAAGjB,IAAI,CAACgB,GAAD,CAAZ;;AAEA,QAAIC,CAAC,CAACT,MAAF,KAAa,CAAjB,EAAoB;AAClB;AACA,aAAOS,CAAC,CAAC,CAAD,CAAR;AACD,KAHD,MAGO,IAAIA,CAAC,CAACT,MAAF,KAAa,CAAjB,EAAoB;AACzB;AACA,UAAIS,CAAC,CAAC,CAAD,CAAD,KAAS,CAAb,EAAgB;AACd;AACA,eAAOA,CAAC,CAAC,CAAD,CAAR;AACD,OAHD,MAGO,IAAIA,CAAC,CAAC,CAAD,CAAD,KAAS,CAAb,EAAgB;AACrB;AACA,eAAOA,CAAC,CAAC,CAAD,CAAR;AACD,OAHM,MAGA;AACL,cAAM,IAAIR,SAAJ,CAAc,gDAAd,CAAN;AACD;AACF,KAXM,MAWA;AACL,YAAM,IAAIA,SAAJ,CAAc,qDAAd,CAAN;AACD;AACF;AACF,CA/EuD,CAAjD","sourcesContent":["import { factory } from '../../utils/factory.js';\nvar name = 'matrixFromRows';\nvar dependencies = ['typed', 'matrix', 'flatten', 'size'];\nexport var createMatrixFromRows = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    flatten,\n    size\n  } = _ref;\n\n  /**\n   * Create a dense matrix from vectors as individual rows.\n   * If you pass column vectors, they will be transposed (but not conjugated!)\n   *\n   * Syntax:\n   *\n   *    math.matrixFromRows(...arr)\n   *    math.matrixFromRows(row1, row2)\n   *    math.matrixFromRows(row1, row2, row3)\n   *\n   * Examples:\n   *\n   *    math.matrixFromRows([1, 2, 3], [[4],[5],[6]])\n   *    math.matrixFromRows(...vectors)\n   *\n   * See also:\n   *\n   *    matrix, matrixFromColumns, matrixFromFunction, zeros\n   *\n   * @param {... Array | Matrix} rows  Multiple rows\n   * @return { number[][] | Matrix } if at least one of the arguments is an array, an array will be returned\n   */\n  return typed(name, {\n    '...Array': function Array(arr) {\n      return _createArray(arr);\n    },\n    '...Matrix': function Matrix(arr) {\n      return matrix(_createArray(arr.map(m => m.toArray())));\n    } // TODO implement this properly for SparseMatrix\n\n  });\n\n  function _createArray(arr) {\n    if (arr.length === 0) throw new TypeError('At least one row is needed to construct a matrix.');\n    var N = checkVectorTypeAndReturnLength(arr[0]);\n    var result = [];\n\n    for (var row of arr) {\n      var rowLength = checkVectorTypeAndReturnLength(row);\n\n      if (rowLength !== N) {\n        throw new TypeError('The vectors had different length: ' + (N | 0) + ' ≠ ' + (rowLength | 0));\n      }\n\n      result.push(flatten(row));\n    }\n\n    return result;\n  }\n\n  function checkVectorTypeAndReturnLength(vec) {\n    var s = size(vec);\n\n    if (s.length === 1) {\n      // 1D vector\n      return s[0];\n    } else if (s.length === 2) {\n      // 2D vector\n      if (s[0] === 1) {\n        // row vector\n        return s[1];\n      } else if (s[1] === 1) {\n        // col vector\n        return s[0];\n      } else {\n        throw new TypeError('At least one of the arguments is not a vector.');\n      }\n    } else {\n      throw new TypeError('Only one- or two-dimensional vectors are supported.');\n    }\n  }\n});"]},"metadata":{},"sourceType":"module"}