{"ast":null,"code":"import { isNode } from '../../utils/is.js';\nimport { keywords } from '../keywords.js';\nimport { escape } from '../../utils/string.js';\nimport { forEach, join } from '../../utils/array.js';\nimport { toSymbol } from '../../utils/latex.js';\nimport { getPrecedence } from '../operators.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'FunctionAssignmentNode';\nvar dependencies = ['typed', 'Node'];\nexport var createFunctionAssignmentNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    Node\n  } = _ref;\n  /**\n   * @constructor FunctionAssignmentNode\n   * @extends {Node}\n   * Function assignment\n   *\n   * @param {string} name           Function name\n   * @param {string[] | Array.<{name: string, type: string}>} params\n   *                                Array with function parameter names, or an\n   *                                array with objects containing the name\n   *                                and type of the parameter\n   * @param {Node} expr             The function expression\n   */\n\n  function FunctionAssignmentNode(name, params, expr) {\n    if (!(this instanceof FunctionAssignmentNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (typeof name !== 'string') throw new TypeError('String expected for parameter \"name\"');\n    if (!Array.isArray(params)) throw new TypeError('Array containing strings or objects expected for parameter \"params\"');\n    if (!isNode(expr)) throw new TypeError('Node expected for parameter \"expr\"');\n    if (keywords.has(name)) throw new Error('Illegal function name, \"' + name + '\" is a reserved keyword');\n    this.name = name;\n    this.params = params.map(function (param) {\n      return param && param.name || param;\n    });\n    this.types = params.map(function (param) {\n      return param && param.type || 'any';\n    });\n    this.expr = expr;\n  }\n\n  FunctionAssignmentNode.prototype = new Node();\n  FunctionAssignmentNode.prototype.type = 'FunctionAssignmentNode';\n  FunctionAssignmentNode.prototype.isFunctionAssignmentNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  FunctionAssignmentNode.prototype._compile = function (math, argNames) {\n    var childArgNames = Object.create(argNames);\n    forEach(this.params, function (param) {\n      childArgNames[param] = true;\n    }); // compile the function expression with the child args\n\n    var evalExpr = this.expr._compile(math, childArgNames);\n\n    var name = this.name;\n    var params = this.params;\n    var signature = join(this.types, ',');\n    var syntax = name + '(' + join(this.params, ', ') + ')';\n    return function evalFunctionAssignmentNode(scope, args, context) {\n      var signatures = {};\n\n      signatures[signature] = function () {\n        var childArgs = Object.create(args);\n\n        for (var i = 0; i < params.length; i++) {\n          childArgs[params[i]] = arguments[i];\n        }\n\n        return evalExpr(scope, childArgs, context);\n      };\n\n      var fn = typed(name, signatures);\n      fn.syntax = syntax;\n      scope.set(name, fn);\n      return fn;\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  FunctionAssignmentNode.prototype.forEach = function (callback) {\n    callback(this.expr, 'expr', this);\n  };\n  /**\n   * Create a new FunctionAssignmentNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {FunctionAssignmentNode} Returns a transformed copy of the node\n   */\n\n\n  FunctionAssignmentNode.prototype.map = function (callback) {\n    var expr = this._ifNode(callback(this.expr, 'expr', this));\n\n    return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {FunctionAssignmentNode}\n   */\n\n\n  FunctionAssignmentNode.prototype.clone = function () {\n    return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);\n  };\n  /**\n   * Is parenthesis needed?\n   * @param {Node} node\n   * @param {Object} parenthesis\n   * @private\n   */\n\n\n  function needParenthesis(node, parenthesis) {\n    var precedence = getPrecedence(node, parenthesis);\n    var exprPrecedence = getPrecedence(node.expr, parenthesis);\n    return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;\n  }\n  /**\n   * get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionAssignmentNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var expr = this.expr.toString(options);\n\n    if (needParenthesis(this, parenthesis)) {\n      expr = '(' + expr + ')';\n    }\n\n    return this.name + '(' + this.params.join(', ') + ') = ' + expr;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  FunctionAssignmentNode.prototype.toJSON = function () {\n    var types = this.types;\n    return {\n      mathjs: 'FunctionAssignmentNode',\n      name: this.name,\n      params: this.params.map(function (param, index) {\n        return {\n          name: param,\n          type: types[index]\n        };\n      }),\n      expr: this.expr\n    };\n  };\n  /**\n   * Instantiate an FunctionAssignmentNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"FunctionAssignmentNode\", name: ..., params: ..., expr: ...}`,\n   *                       where mathjs is optional\n   * @returns {FunctionAssignmentNode}\n   */\n\n\n  FunctionAssignmentNode.fromJSON = function (json) {\n    return new FunctionAssignmentNode(json.name, json.params, json.expr);\n  };\n  /**\n   * get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionAssignmentNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var params = [];\n\n    for (var i = 0; i < this.params.length; i++) {\n      params.push('<span class=\"math-symbol math-parameter\">' + escape(this.params[i]) + '</span>');\n    }\n\n    var expr = this.expr.toHTML(options);\n\n    if (needParenthesis(this, parenthesis)) {\n      expr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + expr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return '<span class=\"math-function\">' + escape(this.name) + '</span>' + '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + params.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-round-parenthesis\">)</span><span class=\"math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator\">=</span>' + expr;\n  };\n  /**\n   * get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionAssignmentNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var expr = this.expr.toTex(options);\n\n    if (needParenthesis(this, parenthesis)) {\n      expr = \"\\\\left(\".concat(expr, \"\\\\right)\");\n    }\n\n    return '\\\\mathrm{' + this.name + '}\\\\left(' + this.params.map(toSymbol).join(',') + '\\\\right):=' + expr;\n  };\n\n  return FunctionAssignmentNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["/Users/sarahrouini/PMN/calculator/node_modules/mathjs/lib/esm/expression/node/FunctionAssignmentNode.js"],"names":["isNode","keywords","escape","forEach","join","toSymbol","getPrecedence","factory","name","dependencies","createFunctionAssignmentNode","_ref","typed","Node","FunctionAssignmentNode","params","expr","SyntaxError","TypeError","Array","isArray","has","Error","map","param","types","type","prototype","isFunctionAssignmentNode","_compile","math","argNames","childArgNames","Object","create","evalExpr","signature","syntax","evalFunctionAssignmentNode","scope","args","context","signatures","childArgs","i","length","arguments","fn","set","callback","_ifNode","slice","clone","needParenthesis","node","parenthesis","precedence","exprPrecedence","_toString","options","toString","toJSON","mathjs","index","fromJSON","json","toHTML","push","_toTex","toTex","concat","isClass"],"mappings":"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","sourcesContent":["import { isNode } from '../../utils/is.js';\nimport { keywords } from '../keywords.js';\nimport { escape } from '../../utils/string.js';\nimport { forEach, join } from '../../utils/array.js';\nimport { toSymbol } from '../../utils/latex.js';\nimport { getPrecedence } from '../operators.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'FunctionAssignmentNode';\nvar dependencies = ['typed', 'Node'];\nexport var createFunctionAssignmentNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    Node\n  } = _ref;\n\n  /**\n   * @constructor FunctionAssignmentNode\n   * @extends {Node}\n   * Function assignment\n   *\n   * @param {string} name           Function name\n   * @param {string[] | Array.<{name: string, type: string}>} params\n   *                                Array with function parameter names, or an\n   *                                array with objects containing the name\n   *                                and type of the parameter\n   * @param {Node} expr             The function expression\n   */\n  function FunctionAssignmentNode(name, params, expr) {\n    if (!(this instanceof FunctionAssignmentNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (typeof name !== 'string') throw new TypeError('String expected for parameter \"name\"');\n    if (!Array.isArray(params)) throw new TypeError('Array containing strings or objects expected for parameter \"params\"');\n    if (!isNode(expr)) throw new TypeError('Node expected for parameter \"expr\"');\n    if (keywords.has(name)) throw new Error('Illegal function name, \"' + name + '\" is a reserved keyword');\n    this.name = name;\n    this.params = params.map(function (param) {\n      return param && param.name || param;\n    });\n    this.types = params.map(function (param) {\n      return param && param.type || 'any';\n    });\n    this.expr = expr;\n  }\n\n  FunctionAssignmentNode.prototype = new Node();\n  FunctionAssignmentNode.prototype.type = 'FunctionAssignmentNode';\n  FunctionAssignmentNode.prototype.isFunctionAssignmentNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  FunctionAssignmentNode.prototype._compile = function (math, argNames) {\n    var childArgNames = Object.create(argNames);\n    forEach(this.params, function (param) {\n      childArgNames[param] = true;\n    }); // compile the function expression with the child args\n\n    var evalExpr = this.expr._compile(math, childArgNames);\n\n    var name = this.name;\n    var params = this.params;\n    var signature = join(this.types, ',');\n    var syntax = name + '(' + join(this.params, ', ') + ')';\n    return function evalFunctionAssignmentNode(scope, args, context) {\n      var signatures = {};\n\n      signatures[signature] = function () {\n        var childArgs = Object.create(args);\n\n        for (var i = 0; i < params.length; i++) {\n          childArgs[params[i]] = arguments[i];\n        }\n\n        return evalExpr(scope, childArgs, context);\n      };\n\n      var fn = typed(name, signatures);\n      fn.syntax = syntax;\n      scope.set(name, fn);\n      return fn;\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  FunctionAssignmentNode.prototype.forEach = function (callback) {\n    callback(this.expr, 'expr', this);\n  };\n  /**\n   * Create a new FunctionAssignmentNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {FunctionAssignmentNode} Returns a transformed copy of the node\n   */\n\n\n  FunctionAssignmentNode.prototype.map = function (callback) {\n    var expr = this._ifNode(callback(this.expr, 'expr', this));\n\n    return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {FunctionAssignmentNode}\n   */\n\n\n  FunctionAssignmentNode.prototype.clone = function () {\n    return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);\n  };\n  /**\n   * Is parenthesis needed?\n   * @param {Node} node\n   * @param {Object} parenthesis\n   * @private\n   */\n\n\n  function needParenthesis(node, parenthesis) {\n    var precedence = getPrecedence(node, parenthesis);\n    var exprPrecedence = getPrecedence(node.expr, parenthesis);\n    return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;\n  }\n  /**\n   * get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionAssignmentNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var expr = this.expr.toString(options);\n\n    if (needParenthesis(this, parenthesis)) {\n      expr = '(' + expr + ')';\n    }\n\n    return this.name + '(' + this.params.join(', ') + ') = ' + expr;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  FunctionAssignmentNode.prototype.toJSON = function () {\n    var types = this.types;\n    return {\n      mathjs: 'FunctionAssignmentNode',\n      name: this.name,\n      params: this.params.map(function (param, index) {\n        return {\n          name: param,\n          type: types[index]\n        };\n      }),\n      expr: this.expr\n    };\n  };\n  /**\n   * Instantiate an FunctionAssignmentNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"FunctionAssignmentNode\", name: ..., params: ..., expr: ...}`,\n   *                       where mathjs is optional\n   * @returns {FunctionAssignmentNode}\n   */\n\n\n  FunctionAssignmentNode.fromJSON = function (json) {\n    return new FunctionAssignmentNode(json.name, json.params, json.expr);\n  };\n  /**\n   * get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionAssignmentNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var params = [];\n\n    for (var i = 0; i < this.params.length; i++) {\n      params.push('<span class=\"math-symbol math-parameter\">' + escape(this.params[i]) + '</span>');\n    }\n\n    var expr = this.expr.toHTML(options);\n\n    if (needParenthesis(this, parenthesis)) {\n      expr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + expr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return '<span class=\"math-function\">' + escape(this.name) + '</span>' + '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + params.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-round-parenthesis\">)</span><span class=\"math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator\">=</span>' + expr;\n  };\n  /**\n   * get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionAssignmentNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var expr = this.expr.toTex(options);\n\n    if (needParenthesis(this, parenthesis)) {\n      expr = \"\\\\left(\".concat(expr, \"\\\\right)\");\n    }\n\n    return '\\\\mathrm{' + this.name + '}\\\\left(' + this.params.map(toSymbol).join(',') + '\\\\right):=' + expr;\n  };\n\n  return FunctionAssignmentNode;\n}, {\n  isClass: true,\n  isNode: true\n});"]},"metadata":{},"sourceType":"module"}