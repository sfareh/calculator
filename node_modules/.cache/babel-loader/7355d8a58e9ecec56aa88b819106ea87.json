{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nimport { format } from '../../utils/string.js';\nimport { createComplexEigs } from './eigs/complexEigs.js';\nimport { createRealSymmetric } from './eigs/realSymetric.js';\nimport { typeOf, isNumber, isBigNumber, isComplex, isFraction } from '../../utils/is.js';\nvar name = 'eigs'; // The absolute state of math.js's dependency system:\n\nvar dependencies = ['config', 'typed', 'matrix', 'addScalar', 'equal', 'subtract', 'abs', 'atan', 'cos', 'sin', 'multiplyScalar', 'divideScalar', 'inv', 'bignumber', 'multiply', 'add', 'larger', 'column', 'flatten', 'number', 'complex', 'sqrt', 'diag', 'qr', 'usolve', 'usolveAll', 'im', 're', 'smaller', 'matrixFromColumns', 'dot'];\nexport var createEigs = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    config,\n    typed,\n    matrix,\n    addScalar,\n    subtract,\n    equal,\n    abs,\n    atan,\n    cos,\n    sin,\n    multiplyScalar,\n    divideScalar,\n    inv,\n    bignumber,\n    multiply,\n    add,\n    larger,\n    column,\n    flatten,\n    number,\n    complex,\n    sqrt,\n    diag,\n    qr,\n    usolve,\n    usolveAll,\n    im,\n    re,\n    smaller,\n    matrixFromColumns,\n    dot\n  } = _ref;\n  var doRealSymetric = createRealSymmetric({\n    config,\n    addScalar,\n    subtract,\n    column,\n    flatten,\n    equal,\n    abs,\n    atan,\n    cos,\n    sin,\n    multiplyScalar,\n    inv,\n    bignumber,\n    complex,\n    multiply,\n    add\n  });\n  var doComplexEigs = createComplexEigs({\n    config,\n    addScalar,\n    subtract,\n    multiply,\n    multiplyScalar,\n    flatten,\n    divideScalar,\n    sqrt,\n    abs,\n    bignumber,\n    diag,\n    qr,\n    inv,\n    usolve,\n    usolveAll,\n    equal,\n    complex,\n    larger,\n    smaller,\n    matrixFromColumns,\n    dot\n  });\n  /**\n   * Compute eigenvalues and eigenvectors of a matrix. The eigenvalues are sorted by their absolute value, ascending.\n   * An eigenvalue with multiplicity k will be listed k times. The eigenvectors are returned as columns of a matrix –\n   * the eigenvector that belongs to the j-th eigenvalue in the list (eg. `values[j]`) is the j-th column (eg. `column(vectors, j)`).\n   * If the algorithm fails to converge, it will throw an error – in that case, however, you may still find useful information\n   * in `err.values` and `err.vectors`.\n   *\n   * Syntax:\n   *\n   *     math.eigs(x, [prec])\n   *\n   * Examples:\n   *\n   *     const { eigs, multiply, column, transpose } = math\n   *     const H = [[5, 2.3], [2.3, 1]]\n   *     const ans = eigs(H) // returns {values: [E1,E2...sorted], vectors: [v1,v2.... corresponding vectors as columns]}\n   *     const E = ans.values\n   *     const U = ans.vectors\n   *     multiply(H, column(U, 0)) // returns multiply(E[0], column(U, 0))\n   *     const UTxHxU = multiply(transpose(U), H, U) // diagonalizes H\n   *     E[0] == UTxHxU[0][0]  // returns true\n   *\n   * See also:\n   *\n   *     inv\n   *\n   * @param {Array | Matrix} x  Matrix to be diagonalized\n   *\n   * @param {number | BigNumber} [prec] Precision, default value: 1e-15\n   * @return {{values: Array|Matrix, vectors: Array|Matrix}} Object containing an array of eigenvalues and a matrix with eigenvectors as columns.\n   *\n   */\n\n  return typed('eigs', {\n    Array: function Array(x) {\n      var mat = matrix(x);\n      return computeValuesAndVectors(mat);\n    },\n    'Array, number|BigNumber': function ArrayNumberBigNumber(x, prec) {\n      var mat = matrix(x);\n      return computeValuesAndVectors(mat, prec);\n    },\n    Matrix: function Matrix(mat) {\n      var {\n        values,\n        vectors\n      } = computeValuesAndVectors(mat);\n      return {\n        values: matrix(values),\n        vectors: matrix(vectors)\n      };\n    },\n    'Matrix, number|BigNumber': function MatrixNumberBigNumber(mat, prec) {\n      var {\n        values,\n        vectors\n      } = computeValuesAndVectors(mat, prec);\n      return {\n        values: matrix(values),\n        vectors: matrix(vectors)\n      };\n    }\n  });\n\n  function computeValuesAndVectors(mat, prec) {\n    if (prec === undefined) {\n      prec = config.epsilon;\n    }\n\n    var size = mat.size();\n\n    if (size.length !== 2 || size[0] !== size[1]) {\n      throw new RangeError('Matrix must be square (size: ' + format(size) + ')');\n    }\n\n    var arr = mat.toArray();\n    var N = size[0];\n\n    if (isReal(arr, N, prec)) {\n      coerceReal(arr, N);\n\n      if (isSymmetric(arr, N, prec)) {\n        var _type = coerceTypes(mat, arr, N);\n\n        return doRealSymetric(arr, N, prec, _type);\n      }\n    }\n\n    var type = coerceTypes(mat, arr, N);\n    return doComplexEigs(arr, N, prec, type);\n  }\n  /** @return {boolean} */\n\n\n  function isSymmetric(arr, N, prec) {\n    for (var i = 0; i < N; i++) {\n      for (var j = i; j < N; j++) {\n        // TODO proper comparison of bignum and frac\n        if (larger(bignumber(abs(subtract(arr[i][j], arr[j][i]))), prec)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n  /** @return {boolean} */\n\n\n  function isReal(arr, N, prec) {\n    for (var i = 0; i < N; i++) {\n      for (var j = 0; j < N; j++) {\n        // TODO proper comparison of bignum and frac\n        if (larger(bignumber(abs(im(arr[i][j]))), prec)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  function coerceReal(arr, N) {\n    for (var i = 0; i < N; i++) {\n      for (var j = 0; j < N; j++) {\n        arr[i][j] = re(arr[i][j]);\n      }\n    }\n  }\n  /** @return {'number' | 'BigNumber' | 'Complex'} */\n\n\n  function coerceTypes(mat, arr, N) {\n    /** @type {string} */\n    var type = mat.datatype();\n\n    if (type === 'number' || type === 'BigNumber' || type === 'Complex') {\n      return type;\n    }\n\n    var hasNumber = false;\n    var hasBig = false;\n    var hasComplex = false;\n\n    for (var i = 0; i < N; i++) {\n      for (var j = 0; j < N; j++) {\n        var el = arr[i][j];\n\n        if (isNumber(el) || isFraction(el)) {\n          hasNumber = true;\n        } else if (isBigNumber(el)) {\n          hasBig = true;\n        } else if (isComplex(el)) {\n          hasComplex = true;\n        } else {\n          throw TypeError('Unsupported type in Matrix: ' + typeOf(el));\n        }\n      }\n    }\n\n    if (hasBig && hasComplex) {\n      console.warn('Complex BigNumbers not supported, this operation will lose precission.');\n    }\n\n    if (hasComplex) {\n      for (var _i = 0; _i < N; _i++) {\n        for (var _j = 0; _j < N; _j++) {\n          arr[_i][_j] = complex(arr[_i][_j]);\n        }\n      }\n\n      return 'Complex';\n    }\n\n    if (hasBig) {\n      for (var _i2 = 0; _i2 < N; _i2++) {\n        for (var _j2 = 0; _j2 < N; _j2++) {\n          arr[_i2][_j2] = bignumber(arr[_i2][_j2]);\n        }\n      }\n\n      return 'BigNumber';\n    }\n\n    if (hasNumber) {\n      for (var _i3 = 0; _i3 < N; _i3++) {\n        for (var _j3 = 0; _j3 < N; _j3++) {\n          arr[_i3][_j3] = number(arr[_i3][_j3]);\n        }\n      }\n\n      return 'number';\n    } else {\n      throw TypeError('Matrix contains unsupported types only.');\n    }\n  }\n});","map":{"version":3,"sources":["/Users/sarahrouini/PMN/calculator/node_modules/mathjs/lib/esm/function/matrix/eigs.js"],"names":["factory","format","createComplexEigs","createRealSymmetric","typeOf","isNumber","isBigNumber","isComplex","isFraction","name","dependencies","createEigs","_ref","config","typed","matrix","addScalar","subtract","equal","abs","atan","cos","sin","multiplyScalar","divideScalar","inv","bignumber","multiply","add","larger","column","flatten","number","complex","sqrt","diag","qr","usolve","usolveAll","im","re","smaller","matrixFromColumns","dot","doRealSymetric","doComplexEigs","Array","x","mat","computeValuesAndVectors","ArrayNumberBigNumber","prec","Matrix","values","vectors","MatrixNumberBigNumber","undefined","epsilon","size","length","RangeError","arr","toArray","N","isReal","coerceReal","isSymmetric","_type","coerceTypes","type","i","j","datatype","hasNumber","hasBig","hasComplex","el","TypeError","console","warn","_i","_j","_i2","_j2","_i3","_j3"],"mappings":"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","sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { format } from '../../utils/string.js';\nimport { createComplexEigs } from './eigs/complexEigs.js';\nimport { createRealSymmetric } from './eigs/realSymetric.js';\nimport { typeOf, isNumber, isBigNumber, isComplex, isFraction } from '../../utils/is.js';\nvar name = 'eigs'; // The absolute state of math.js's dependency system:\n\nvar dependencies = ['config', 'typed', 'matrix', 'addScalar', 'equal', 'subtract', 'abs', 'atan', 'cos', 'sin', 'multiplyScalar', 'divideScalar', 'inv', 'bignumber', 'multiply', 'add', 'larger', 'column', 'flatten', 'number', 'complex', 'sqrt', 'diag', 'qr', 'usolve', 'usolveAll', 'im', 're', 'smaller', 'matrixFromColumns', 'dot'];\nexport var createEigs = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    config,\n    typed,\n    matrix,\n    addScalar,\n    subtract,\n    equal,\n    abs,\n    atan,\n    cos,\n    sin,\n    multiplyScalar,\n    divideScalar,\n    inv,\n    bignumber,\n    multiply,\n    add,\n    larger,\n    column,\n    flatten,\n    number,\n    complex,\n    sqrt,\n    diag,\n    qr,\n    usolve,\n    usolveAll,\n    im,\n    re,\n    smaller,\n    matrixFromColumns,\n    dot\n  } = _ref;\n  var doRealSymetric = createRealSymmetric({\n    config,\n    addScalar,\n    subtract,\n    column,\n    flatten,\n    equal,\n    abs,\n    atan,\n    cos,\n    sin,\n    multiplyScalar,\n    inv,\n    bignumber,\n    complex,\n    multiply,\n    add\n  });\n  var doComplexEigs = createComplexEigs({\n    config,\n    addScalar,\n    subtract,\n    multiply,\n    multiplyScalar,\n    flatten,\n    divideScalar,\n    sqrt,\n    abs,\n    bignumber,\n    diag,\n    qr,\n    inv,\n    usolve,\n    usolveAll,\n    equal,\n    complex,\n    larger,\n    smaller,\n    matrixFromColumns,\n    dot\n  });\n  /**\n   * Compute eigenvalues and eigenvectors of a matrix. The eigenvalues are sorted by their absolute value, ascending.\n   * An eigenvalue with multiplicity k will be listed k times. The eigenvectors are returned as columns of a matrix –\n   * the eigenvector that belongs to the j-th eigenvalue in the list (eg. `values[j]`) is the j-th column (eg. `column(vectors, j)`).\n   * If the algorithm fails to converge, it will throw an error – in that case, however, you may still find useful information\n   * in `err.values` and `err.vectors`.\n   *\n   * Syntax:\n   *\n   *     math.eigs(x, [prec])\n   *\n   * Examples:\n   *\n   *     const { eigs, multiply, column, transpose } = math\n   *     const H = [[5, 2.3], [2.3, 1]]\n   *     const ans = eigs(H) // returns {values: [E1,E2...sorted], vectors: [v1,v2.... corresponding vectors as columns]}\n   *     const E = ans.values\n   *     const U = ans.vectors\n   *     multiply(H, column(U, 0)) // returns multiply(E[0], column(U, 0))\n   *     const UTxHxU = multiply(transpose(U), H, U) // diagonalizes H\n   *     E[0] == UTxHxU[0][0]  // returns true\n   *\n   * See also:\n   *\n   *     inv\n   *\n   * @param {Array | Matrix} x  Matrix to be diagonalized\n   *\n   * @param {number | BigNumber} [prec] Precision, default value: 1e-15\n   * @return {{values: Array|Matrix, vectors: Array|Matrix}} Object containing an array of eigenvalues and a matrix with eigenvectors as columns.\n   *\n   */\n\n  return typed('eigs', {\n    Array: function Array(x) {\n      var mat = matrix(x);\n      return computeValuesAndVectors(mat);\n    },\n    'Array, number|BigNumber': function ArrayNumberBigNumber(x, prec) {\n      var mat = matrix(x);\n      return computeValuesAndVectors(mat, prec);\n    },\n    Matrix: function Matrix(mat) {\n      var {\n        values,\n        vectors\n      } = computeValuesAndVectors(mat);\n      return {\n        values: matrix(values),\n        vectors: matrix(vectors)\n      };\n    },\n    'Matrix, number|BigNumber': function MatrixNumberBigNumber(mat, prec) {\n      var {\n        values,\n        vectors\n      } = computeValuesAndVectors(mat, prec);\n      return {\n        values: matrix(values),\n        vectors: matrix(vectors)\n      };\n    }\n  });\n\n  function computeValuesAndVectors(mat, prec) {\n    if (prec === undefined) {\n      prec = config.epsilon;\n    }\n\n    var size = mat.size();\n\n    if (size.length !== 2 || size[0] !== size[1]) {\n      throw new RangeError('Matrix must be square (size: ' + format(size) + ')');\n    }\n\n    var arr = mat.toArray();\n    var N = size[0];\n\n    if (isReal(arr, N, prec)) {\n      coerceReal(arr, N);\n\n      if (isSymmetric(arr, N, prec)) {\n        var _type = coerceTypes(mat, arr, N);\n\n        return doRealSymetric(arr, N, prec, _type);\n      }\n    }\n\n    var type = coerceTypes(mat, arr, N);\n    return doComplexEigs(arr, N, prec, type);\n  }\n  /** @return {boolean} */\n\n\n  function isSymmetric(arr, N, prec) {\n    for (var i = 0; i < N; i++) {\n      for (var j = i; j < N; j++) {\n        // TODO proper comparison of bignum and frac\n        if (larger(bignumber(abs(subtract(arr[i][j], arr[j][i]))), prec)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n  /** @return {boolean} */\n\n\n  function isReal(arr, N, prec) {\n    for (var i = 0; i < N; i++) {\n      for (var j = 0; j < N; j++) {\n        // TODO proper comparison of bignum and frac\n        if (larger(bignumber(abs(im(arr[i][j]))), prec)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  function coerceReal(arr, N) {\n    for (var i = 0; i < N; i++) {\n      for (var j = 0; j < N; j++) {\n        arr[i][j] = re(arr[i][j]);\n      }\n    }\n  }\n  /** @return {'number' | 'BigNumber' | 'Complex'} */\n\n\n  function coerceTypes(mat, arr, N) {\n    /** @type {string} */\n    var type = mat.datatype();\n\n    if (type === 'number' || type === 'BigNumber' || type === 'Complex') {\n      return type;\n    }\n\n    var hasNumber = false;\n    var hasBig = false;\n    var hasComplex = false;\n\n    for (var i = 0; i < N; i++) {\n      for (var j = 0; j < N; j++) {\n        var el = arr[i][j];\n\n        if (isNumber(el) || isFraction(el)) {\n          hasNumber = true;\n        } else if (isBigNumber(el)) {\n          hasBig = true;\n        } else if (isComplex(el)) {\n          hasComplex = true;\n        } else {\n          throw TypeError('Unsupported type in Matrix: ' + typeOf(el));\n        }\n      }\n    }\n\n    if (hasBig && hasComplex) {\n      console.warn('Complex BigNumbers not supported, this operation will lose precission.');\n    }\n\n    if (hasComplex) {\n      for (var _i = 0; _i < N; _i++) {\n        for (var _j = 0; _j < N; _j++) {\n          arr[_i][_j] = complex(arr[_i][_j]);\n        }\n      }\n\n      return 'Complex';\n    }\n\n    if (hasBig) {\n      for (var _i2 = 0; _i2 < N; _i2++) {\n        for (var _j2 = 0; _j2 < N; _j2++) {\n          arr[_i2][_j2] = bignumber(arr[_i2][_j2]);\n        }\n      }\n\n      return 'BigNumber';\n    }\n\n    if (hasNumber) {\n      for (var _i3 = 0; _i3 < N; _i3++) {\n        for (var _j3 = 0; _j3 < N; _j3++) {\n          arr[_i3][_j3] = number(arr[_i3][_j3]);\n        }\n      }\n\n      return 'number';\n    } else {\n      throw TypeError('Matrix contains unsupported types only.');\n    }\n  }\n});"]},"metadata":{},"sourceType":"module"}